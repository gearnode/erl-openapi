{{=@@ @@=}}
%% File generated by erl-openapi on @@datetime@@.

-module(@@package_name@@).

-export([encode_q/4, encode_h/4]).

@@#functions@@
-export([@@name@@/1, @@name@@/2]).
@@/functions@@

-export_type([options/0, result/1, error/0, error_reason/0]).
@@#functions@@
-export_type([@@name@@_request/0,
              @@name@@_request_query/0,
              @@name@@_request_header/0,
              @@name@@_request_cookie/0,
              @@name@@_request_body/0,
              @@name@@_response/0]).
@@/functions@@

-type options() ::
        #{request_options => mhttp:request_options(),
          host => uri:host(),
          scheme => uri:scheme(),
          port => uri:port_number()}.

-type result(T) ::
        {ok, T, mhttp:response()}
      | {error, error()}.

-type error() ::
        #{reason := error_reason(),
          request => mhttp:request(),
          response => mhttp:response()}.

-type error_reason() ::
        {mhttp, mhttp:error_reason()}
      | missing_content_type
      | unsupported_content_type
      | {invalid_content_type, mhttp_media_type:error_reason()}
      | {invalid_payload, {json, json:error()}}
      | {invalid_payload, {jsv, [jsv:value_error()]}}.

@@#functions@@
-type @@name@@_request() :: @@types.request@@.

-type @@name@@_request_query() :: @@types.query@@.

-type @@name@@_request_header() :: @@types.header@@.

-type @@name@@_request_cookie() :: @@types.cookie@@.

-type @@name@@_request_body() :: @@types.body@@.

-type @@name@@_response() :: @@types.response@@.

@@/functions@@


@@#functions@@
-spec @@name@@(@@name@@_request()) -> result(@@name@@_response()).
@@name@@(Args) ->
  @@name@@(Args, #{}).

-spec @@name@@(@@name@@_request(), options()) -> result(@@name@@_response()).
@@name@@(Args, Options) ->
  @@#function.parameters.path@@
  Var@@pascal_name@@ = maps:get(@@snake_name@@, Args),
  @@/function.parameters.path@@
  Query = maps:get(query, Args, #{}),
  Header = maps:get(header, Args, #{}),
  EncodeQuery =
    fun
      @@#function.parameters.query@@
      ({@@snake_name@@, Value}) ->
        encode_q(@@style@@, @@explode@@, <<"@@real_name@@">>, Value);
      @@/function.parameters.query@@
      ({Key, Value}) ->
        [{Key, Value}]
    end,
  EncodeHeader =
    fun
      @@#function.parameters.header@@
      ({@@snake_name@@, Value}) ->
        encode_h(@@style@@, @@explode@@, <<"@@real_name@@">>, Value);
      @@/function.parameters.header@@
      ({Key, Value}) ->
        [{Key, Value}]
    end,
  ReqPath = io_lib:format("@@function.http_path@@", @@function.http_path_args@@),
  ReqQuery =
    lists:flatmap(EncodeQuery, maps:to_list(Query)),
  ReqHeader =
    lists:flatmap(EncodeHeader, maps:to_list(Header)),
  ReqOptions = maps:get(request_options, Options, #{}),
  Req = #{method => @@function.http_verb@@,
          header => ReqHeader,
          target => #{scheme => maps:get(scheme, Options, <<"https">>),
                      port => maps:get(port, Options, 443),
                      host => maps:get(host, Options, <<"@@function.http_host@@">>),
                      path => iolist_to_binary(ReqPath),
                      query => ReqQuery}},
  case mhttp:send_request(Req, ReqOptions) of
    {ok, Resp} ->
      RespBody = mhttp_response:body(Resp),
      RespHeader = mhttp_response:header(Resp),
      case mhttp_header:find(RespHeader, <<"Content-Type">>) of
        {ok, MediaTypeValue} ->
          case mhttp_media_type:parse(MediaTypeValue) of
            {ok, MediaType} ->
              case mhttp_response:status(Resp) of
                @@#responses@@
                @@status@@ ->
                  case MediaType of
                  @@#media_types@@
                    @@media_type@@ ->
                      case json:parse(RespBody) of
                        {ok, Data} ->
                          ValidateOpts =
                            #{disable_verification => true,
                              unknown_member_handling => keep,
                              null_member_handling => remove},
                          case jsv:validate(Data, @@jsv_schema@@, ValidateOpts) of
                            {ok, Schema} ->
                              {ok, Schema, Resp};
                            {error, Errors} ->
                              {error, #{reason =>
                                          {invalid_payload, {jsv, Errors}},
                                        request => Req,
                                        response => Resp}}
                          end;
                        {error, Error} ->
                          {error, #{reason => {invalid_payload, {json, Error}},
                                    request => Req,
                                    response => Resp}}
                      end;
                  @@/media_types@@
                    _ ->
                      {error, #{reason => unsupported_content_type,
                                request => Req,
                                response => Resp}}
                  end;
                @@/responses@@
                _ ->
                  case MediaType of
                  @@#default_response@@
                    @@media_type@@ ->
                      case json:parse(RespBody) of
                        {ok, Data} ->
                          ValidateOpts =
                            #{disable_verification => true,
                              unknown_member_handling => keep,
                              null_member_handling => remove},
                          case jsv:validate(Data, @@jsv_schema@@, ValidateOpts) of
                            {ok, Schema} ->
                              {ok, Schema, Resp};
                            {error, Errors} ->
                              {error, #{reason =>
                                          {invalid_payload, {jsv, Errors}},
                                        request => Req,
                                        response => Resp}}
                          end;
                        {error, Error} ->
                          {error, #{reason => {invalid_payload, {json, Error}},
                                    request => Req,
                                    response => Resp}}
                      end;
                  @@/default_response@@
                    _ ->
                      {error, #{reason => unsupported_content_type,
                                request => Req,
                                response => Resp}}
                  end
              end;
            {error, Reason} ->
              {error, #{reason => {invalid_content_type, Reason},
                        request => Req,
                        response => Resp}}
          end;
        error ->
          {error, #{reason => missing_content_type,
                    request => Req,
                    response => Resp}}
      end;
    {error, Reason} ->
      {error, #{reason => {mhttp, Reason},
                request => Req}}
  end.
@@/functions@@

-spec encode_q(Style, Explode, Key, Value) -> uri:query()
          when Style :: form | spaceDelimitde | pipeDelimited | deepObject,
               Explode :: boolean(),
               Key :: binary(),
               Value :: term().
encode_q(form, true, Key, Value) when is_binary(Value) ->
  [{Key, Value}];
encode_q(form, true, Key, Value) when is_integer(Value) ->
  [{Key, integer_to_binary(Value)}];
encode_q(form, true, Key, Value) when is_atom(Value) ->
  [{Key, atom_to_binary(Value)}];
encode_q(form, true, Key, Values) when is_list(Values) ->
  lists:map(
    fun
      (Value) when is_binary(Value) -> {Key, Value};
      (Value) when is_integer(Value) -> {Key, integer_to_binary(Value)};
      (Value) when is_atom(Value) -> {Key, atom_to_binary(Value)}
    end, Values);
encode_q(form, true, _Key, Values) when is_map(Values) ->
  maps:fold(
    fun
      (Key, Value, Acc) when is_binary(Value) ->
        [{Key, Value} | Acc];
      (Key, Value, Acc) when is_integer(Value) ->
        [{Key, integer_to_binary(Value)} | Acc];
      (Key, Value, Acc) when is_atom(Value) ->
        [{Key, atom_to_binary(Key)} | Acc]
    end, [], Values);

encode_q(form, false, Key, Value) when is_binary(Value) ->
  [{Key, Value}];
encode_q(form, false, Key, Value) when is_integer(Value) ->
  [{Key, integer_to_binary(Value)}];
encode_q(form, false, Key, Value) when is_atom(Value) ->
  [{Key, atom_to_binary(Value)}];
encode_q(form, false, Key, Values) when is_list(Values) ->
  Values1 =
    lists:map(
      fun
        (Value) when is_binary(Value) -> Value;
        (Value) when is_integer(Value) -> integer_to_binary(Value);
        (Value) when is_atom(Value) -> atom_to_binary(Value)
      end, Values),
  [{Key, unicode:characters_to_binary(lists:join(",", Values1))}];
encode_q(form, false, Key, Values) when is_map(Values) ->
  Values1 =
    maps:fold(
      fun
        (K, V, Acc) when is_binary(V) ->
          [[K, $,, V] | Acc];
        (K, V, Acc) when is_integer(V) ->
          [[K, $,, integer_to_binary(V)] | Acc];
        (K, V, Acc) when is_atom(V) ->
          [[K, $,, atom_to_binary(V)] | Acc]
      end, [], Values),
  [{Key, unicode:characters_to_binary(lists:join(",", Values1))}];

%% deepObject MUST not encode primary or array value but Stripe use this style
%% to encode query parameter. So I'm force to extend the spec.
encode_q(deepObject, true, Key, Value) when is_binary(Value) ->
  [{Key, Value}];
encode_q(deepObject, true, Key, Value) when is_integer(Value) ->
  [{Key, integer_to_binary(Value)}];
encode_q(deepObject, true, Key, Value) when is_atom(Value) ->
  [{Key, atom_to_binary(Value)}];
encode_q(deepObject, true, Key, Values) when is_list(Values) ->
  lists:map(
    fun
      (Value) when is_binary(Value)->
        {<<Key/binary, "[]">>, Value};
      (Value) when is_integer(Value) ->
        {<<Key/binary, "[]">>, integer_to_binary(Value)};
      (Value) when is_atom(Value) ->
        {<<Key/binary, "[]">>, atom_to_binary(Value)}
    end, Values);
encode_q(deepObject, true, Key, Values) when is_map(Values) ->
  maps:fold(
    fun
      (K, V, Acc) when is_binary(V) ->
        K2 = atom_to_binary(K),
        [{<<Key/binary, $[, K2/binary, $]>>, V} | Acc];
      (K, V, Acc) when is_integer(V) ->
        K2 = atom_to_binary(K),
        [{<<Key/binary, $[, K2/binary, $]>>, integer_to_binary(V)} | Acc];
      (K, V, Acc) when is_atom(V) ->
        K2 = atom_to_binary(K),
        [{<<Key/binary, $[, K2/binary, $]>>, atom_to_binary(V)} | Acc]
    end, [], Values).

-spec encode_h(Style, Explode, Key, Value) -> mhttp:header()
          when Style :: simple,
               Explode :: boolean(),
               Key :: binary(),
               Value :: term().
encode_h(simple, false, Key, Value) when is_binary(Value) ->
  [{Key, Value}];
encode_h(simple, false, Key, Value) when is_integer(Value) ->
  [{Key, integer_to_binary(Value)}];
encode_h(simple, false, Key, Value) when is_atom(Value) ->
  [{Key, atom_to_binary(Value)}];
encode_h(simple, false, Key, Values) when is_list(Values) ->
  [{Key,
    unicode:characters_to_binary(
      lists:join(
        ",",
        lists:map(
          fun
            (Value) when is_binary(Value) -> Value;
            (Value) when is_integer(Value) -> integer_to_binary(Value);
            (Value) when is_atom(Value) -> atom_to_binary(Value)
          end, Values)))}];
encode_h(simple, false, Key, Values) when is_map(Values) ->
  [{Key,
    unicode:characters_to_binary(
      lists:join(
        ",",
        maps:fold(
          fun
            (K, V, Acc) when is_binary(V) ->
              [[K, $,, V] | Acc];
            (K, V, Acc) when is_integer(V) ->
              [[K, $,, integer_to_binary(V)] | Acc];
            (K, V, Acc) when is_atom(V) ->
              [[K, $,, atom_to_binary(V)] | Acc]
          end, [], Values)))}];

encode_h(simple, true, Key, Value) when is_binary(Value) ->
  [{Key, Value}];
encode_h(simple, true, Key, Value) when is_integer(Value) ->
  [{Key, integer_to_binary(Value)}];
encode_h(simple, true, Key, Value) when is_atom(Value) ->
  [{Key, atom_to_binary(Value)}];
encode_h(simple, true, Key, Values) when is_list(Values) ->
  [{Key,
    unicode:characters_to_binary(
      lists:join(
        ",",
        lists:map(
          fun
            (Value) when is_binary(Value) -> Value;
            (Value) when is_integer(Value) -> integer_to_binary(Value);
            (Value) when is_atom(Value) -> atom_to_binary(Value)
          end, Values)))}];
encode_h(simple, true, Key, Values) when is_map(Values) ->
  [{Key,
    unicode:characters_to_binary(
      lists:join(
        ",",
        maps:fold(
          fun
            (K, V, Acc) when is_binary(V) ->
              [[K, $=, V] | Acc];
            (K, V, Acc) when is_integer(V) ->
              [[K, $=, integer_to_binary(V)] | Acc];
            (K, V, Acc) when is_atom(V) ->
              [[K, $=, atom_to_binary(V)] | Acc]
          end, [], Values)))}].
